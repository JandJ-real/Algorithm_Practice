//dp（动态规划）
#include <iostream>
#include <vector>

unsigned long long comb(unsigned long long n, unsigned long long k) {
    if (k > n) return 0;
    std::vector<std::vector<unsigned long long>> dp(n + 1, std::vector<unsigned long long>(k + 1, 0));
    for (unsigned long long i = 0; i <= n; ++i) {
        for (unsigned long long j = 0; j <= std::min(i, k); ++j) {
            if (j == 0 || j == i) {
                dp[i][j] = 1;
            } else {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            }
        }
    }
    return dp[n][k];
}

int main() {
    std::cout << comb(5, 2) << std::endl; // 输出 10
    return 0;
}



//公式优化，避免浮点数
#include <iostream>

unsigned long long comb(unsigned long long n, unsigned long long k) {
    if (k > n) return 0;
    if (k > n - k) k = n - k; // 优化计算
    unsigned long long res = 1;
    for (unsigned long long i = 1; i <= k; ++i) {
        res *= (n - k + i);
        res /= i;
    }
    return res;
}

int main() {
    std::cout << comb(5, 2) << std::endl; // 输出 10
    return 0;
}